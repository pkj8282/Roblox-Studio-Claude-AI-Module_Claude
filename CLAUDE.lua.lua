-- # CLAUDE.lua

-- 이 파일은 이 작업공간에서을 할 때 Claude (claude.ai/Roblox Studio)에 대한 가이드를 제공합니다.

-- +++

-- ## 언어 설정

-- **모든 응답과 커뮤니케이션은 한국어로 진행하세요.** 
-- 코드 주석, 커밋 메시지, 문서화, 사용자와의 대화 등 모든 상황에서 한국어를 사용합니다.

-- +++

-- ## MCP

-- 다음과 같은 MCP 를 적극 활용하기 바람.

-- - Roblox Studio MCP
-- - context7 MCP
-- - sequential-thinking MCP
-- - playwright MCP

-- +++

-- ## 엑세스

-- **허용된 엑세스 중에서 포함되지 않는 접근은 허용하지 않습니다.**
-- **허용된 엑세스에 포함된 모든 요소들은 기본적으로 접근이 허용되며 엑세스에 포함된 요소들 중 허용되지 않는 요소들은 (엑세스 / {엑세스에 포함된 요소들 중 허용되지 않는 요소들의 접근 위치들})의 형식으로 작성됩니다.**

-- - game.ServerStorage
-- - game.ServerScriptService
-- - game.ReplicatedStorage
-- - game.ReplicatedFirst
-- - game.MaterialService
-- - game.Players
-- - game.Workspace
-- - game.StarterPlayer
-- - game.Teams

-- ## 분석용 저장소 관리
-- **분석 요소들을 모으는 저장 공간에 대해 위치를 표시합니다.**
-- **저장 공간 위치가 엑세스에 포함되지 않거나 비어있다면 Claude의 판단 하에 분석용 저장소를 엑세스 중 한 엑세스에 저장 할 수 있습니다. 다만, 분석용 저장소 사용 플래그가 false라면 분석용 저장소를 만들 수 없습니다.**

-- *분석용 저장소 사용 플래그*: true
-- *분석용 저장소 위치*: game.ServerStorage

-- +++

-- ## 작업 시작 전 체크리스트

-- **작업이 시작할려면 다음과 같은 체크리스트가 통과되어야 합니다.**
-- 작업이 통과되지 못한 경우, 다음과 같은 절차를 실행합니다.

-- ### 체크리스트 통과 실패의 경우에 대한 절차
-- 1. **작업 취소와 통과 실패 부분에 대해 문제점 분석**: 작업을 시작하는 것을 취소하고 체크리스트에서 통과되지 못한 부분에 대해 문제점을 분석합니다.
-- 2. **분석한 문제점을 사용자에게 필요한 절차를 요청**: 사용자에게 분석한 문제점을 알려주며 해결을 위한 절차를 알려주고 요청합니다.
-- 3. **사용자의 응답 대기**: 사용자의 절차 완료 응답을 대기하고 응답을 받으면 다시 체크리스트를 확인합니다. 체크리스트가 계속 통과되지 못한다면 *최대 3번까지* <@체크리스트 통과 실패의 경우에 대한 절차>를 실행합니다.

-- ### 체크리스트
-- - [ ] <@MCP> 목록에 포함된 MCP들이 전부 작동하는가?
-- - [ ] <@엑세스> 목록에 포함된 엑세스들이 존재하는가?
-- - [ ] 사용자의 요청이 게임 설정에서 활성화 해야하는 서비스가 필요할 떄 서비스를 미리 호출 함으로써 서비스가 호출 가능한가?
-- - [ ] 사용자의 요청에서 필요한 엑세스가 <@엑세스> 목록에 포함 되고, 필요한 요소가 허용되어 있는가?

-- +++

-- ## 작업 시 주의사항
-- 1. **전역 || 로컬**: 작업중 여러 체계에 사용될 가능성이 있는 작업은 필요 유무를 고려하여 필요한 부분만 전역으로 작업, 그 외 부분은 로컬로 작업
-- 2. **과도한 작업 금지**: 단순한 작업까지 특정 작업에만 무리하게 집중적으로 작업하지 않음, 최적의 수준으로 작업
-- 3. **각 작업들에 대해 완료 시 테스트**: 작업중인 작업이 완료되면 그 작업에 대한 테스트를 진행하고 테스트 결과에서 문제가 발견되었다면 문제를 해결 후 다음 작업을 실행

-- +++

-- ## 작업 시 규칙

-- ### 객체 관리
-- **서버 사이드**: 서버만 오직 접근 가능한 객체
-- **클라이언트 사이드**: 클라이언트만 오직 접근 가능한 객체
-- **공유 사이드**: 클라이언트, 서버 모두 접근 가능한 객체
-- **서버 감독 공유 사이드**: 공유 사이드의 특성을 갖고 있지만 서버가 클라이언트의 접근을 관리 할 수 있는 객체

-- ### 설계 구조
-- | 설계
-- | 프레임 워크
-- |       └── 메인
-- | └── 서버
-- |       └── 서버 + 메인
-- | └── 클라이언트 └─────────────────────────────────────── (서버, 클라이언트) + 메인
-- |       └── 클라이언트 + 메인 ───────┘


-- ### 클라이언트 보안
-- **클라이언트 보안은 클라이언트 사이드로 진행됩니다.**
-- game.StarterPlayer.StarterPlayerScripts에 localscript를 추가하여 코드를 작성하세요.

-- #### 서버에서 발생한 상호작용 확인
-- 1. **엑세스에서 발생한 변화에 대해 서버에 확인 요청**: <@엑세스> 목록에서 클라이언트가 접근 가능한 엑세스를 이용하여 클라이언트 내에서 특정 객체를 바꾸거나 상호작용 한 것을 감지했을 떄 서버에 의한 것인지 확인 요청합니다.
-- 2. **서버의 응답 대기**: 서버가 확인 요청에 대해 응답할 떄까지 대기하며 응답 완료시 서버에 의한 것이 아니라면 서버에 감독 요청을 합니다.

-- #### 서버의 클라이언트 데이터 정보 요청
-- 1. **서버의 요청 응답**: 서버가 클라이언트 데이터 정보를 요청할 때 <@엑세스> 목록에서 클라이언트가 접근 가능한 엑세스에서 최대한 중요하고 민감한 정보를 우선으로 정보를 보냅니다.

-- ### 서버 보안
-- **서버 보안은 서버 사이드로 진행됩니다.**
-- game.ServerScriptService에 script를 추가하여 코드를 작성하세요.

-- #### 특정 클라이언트 감독
-- 1. **감독 요청을 받은 클라이언트 확인**: 감독 요청을 받은 클라이언트가 현재 참가중인지 확인하며 참가 중이지 않다면 해당 감독을 취소합니다.
-- 2. **클라이언트 감독**: 클라이언트에게 현재 클라이언트 데이터 정보를 요청합니다.
-- 3. **데이터 정보 응답 대기와 분석**: 클라이언트의 데이터 정보 응답을 대기하고 응답 완료시 주어진 데이터를 현재 서버의 데이터와 비교하여 중요하고 민감한 정보가 다른지 확인합니다.
-- 4. **데이터 분석에 대한 대응**: 분석 결과에서 다르다는 것이 확인되면 해당 클라이언트의 연결을 헤제합니다. 분석 결과가 같다면 **최대 3회까지** 3분 간격으로 이 절차를 반복합니다.

-- ### 보안 체크리스트
-- - [] 민감한 데이터는 <@객체 관리>/서버 감독 공유 사이드/ 혹은 <@겍체 관리>/서버 사이드/로 설정
-- - [] 클라이언트의 요청에서 보안적인 밀접 관계가 있는 요청은 적절한 RLS 정책을 설정
-- - [] 서버와 클라이언트의 상호작용이 서버와 밀접한 경우 중요한 상호작용으로 서버가 우선적으로 활동

-- ### lua 코드 작성 시 규칙
-- **백업**: 코드를 편집하는 것이라면 편집 하기 전에 미리 코드 혹은 해당 코드의 최상위 모델 및 폴더(기본적인 서비스 디렉토리 제외)로부터 복제하여 <game.ServerStorage> 에 저장합니다. 백업본 이름 저장 방식: 서비스 디렉토리 경로_타임스탬프
-- **사용자의 검증**: 모든 코드는 작성을 마치면 사용자에게 코드를 보여주고 사용자가 거절하거나 허용 및 제안 할 수 있도록 대기 합니다.
-- **최적화**: 모든 코드는 최적화 절차를 통해 완료되어야 합니다.
-- **불필요한 인덱싣**: 필요하지 않은 요소를 인덱싱 하지 않습니다.

-- ++ ❌ 나쁜 예: 모든 요소를 조회
-- for i, v in table do

-- end

-- ++ ✅ 좋은 예: 필터링하여 필요한 요소들만 있는 집합에서 조회
-- for i, v in filtered_table do

-- end

-- **재사용 가능성 있는 코드 함수화**: 재사용 가능성 있는 코드들은 함수로 저장하여 사용합니다.
-- **중간 테스트**: 코드 작성중 각 부분을 작성 완료 시 부분적으로 테스트
-- **체크리스트 충족**: 체크리스트를 참고하여 좋은 코드를 작성합니다.

-- #### 최적화 절차
-- 1. **코드 분석**: 최적화를 진행할 코드를 전체적으로 분석합니다.
-- 2. **알고리즘 및 코드 재구성**: 분석한 코드를 바탕하여 코드에서 발생하는 결과, 작동 과정 등을 비교하여 더욱 최적적이고 정상적인 코드로 재구성 하며 재구성 전의 코드를 임시 저장 합니다.
-- 3. **재구성에서 발생하는 문제 해결**: 재구성된 코드에서 발생하는 오류를 재구성 전의 코드와 비교하여 오류를 해결합니다.
-- 4. **위 과정을 반복**: 위 과정을 반복하며 2번 절차에서 더 이상 최적화가 필요하지 않다면 최적화 절차를 완료합니다.

-- #### lua 코드 작성시 체크리스트
-- - [ ] 코드 작성에서 200줄 이하로 간결하게 작성이 가능한가?
-- - [ ] 존재 하지 않는 객체에 대한 상호작용이 있는가?
-- - [ ] 정상 작동이 가능한가?
-- - [ ] 코드에서 필요한 함수가 존재한가?
-- - [ ] 코드에서 필요한 함수가 상호작용하는가?
-- - [ ] 코드에서 클라이언트와 서버와 상호작용 한다면 상호작용에서 문제가 발생하는가?

-- ### lua 코드 분석 시 규칙
-- **코드 분석 체계를 이용하여 분석합니다.**
-- #### 코드 분석 체계
-- | 함수
-- |  └── 우선순위: 다른 스크립트 끼리 공유되는 함수 > 함수끼리 공유하는 함수 > 함수 체계에서 또다른 함수를 이용하는 함수 > 재귀 함수 > 일반적인 함수
-- |  └── 분석 체계
-- |       └── 전역 변수를 사용하는가? / 맞다면 전역 변수에 대해서 다른 함수 들과 비교해 공통적인 함수가 있는지 탐색 / 있다면 공통적인 함수들의 코드를 비교하여 기록
-- |       └── 지역 변수를 사용하는가? / 맞다면 지역 변수중에 전역 변수를 연결하는 변수가 있는지 확인 / 있다면 해당 연결 위치를 탐색하고 다른 함수들과 비교해 공통적인 함수가 있는지 탐색 / 있다면 공통적인 함수들의 코드를 비교하여 기록
-- |       └── 함수가 어느 이벤트 핸들러와 연결되는 것이 있는가? / 있다면 다른 함수들 중에 공통적으로 이벤트 핸들러와 연결된 함수가 있는지 탐색 / 있다면 공통적인 함수들의 코드를 비교하여 기록
-- |       └── 함수 내에 다른 스크립트와 연결되는 것이 있는가? / 있다면 다른 함수들 중에 공통적으로 스크립트와 연결된 함수가 있는지 탐색 / 있다면 공통적인 함수들의 코드를 비교하여 기록
-- | 이벤트 핸들러
-- |  └── 우선 순위: 사용되는 함수가 많은 이벤트 핸들러 > 코드가 길고 연결되는 부분이 많은 이벤트 핸들러 > 이벤트 핸들러에 또 다른 이벤트 핸들러가 적용된 이벤트 핸들러 > 재귀 함수 가드가 적용된 이벤트 핸들러 > 일반적인 이벤트 핸들러
-- | 변수
-- |  └── 우선 순위: 다른 스크립트와 연결된 변수 > 함수와 연결된 변수 > 특정 위치를 저장한 변수 > 일반적인 변수
-- |  └── 분석 체계
-- |       └── 변수 연결 부분이 사용자의 요청에서 필요한 부분인가? / 맞다면 기록
-- |── 모든 시퀀스는 각 조건이 미 충족시 기본적으로 연관성 부분, 코드 구조(트리 구조로 표시)를 분석해야함, 조건이 충족중 특정 부분에서 미충족했다면 충족된 부분 까지만 기록하고 최종 분석 시퀀스에서 기록 한 것을 참고하여 분석
-- |── 사용자가 지정한 코드에서 분석한 결과가 사용자의 요청과 전혀 다른 결과일 떄: 만약 사용자가 필요 시 추가 분석 스크립트 위치를 알려주었다면 위치를 참고하여 해당 스크립트를 추가 분석

-- +++

-- ## 고차원적 지능형 처리 구조
-- **매우 중요한 요소중 하나이며 Claude의 LLM이 어떠한 상황에서든 자기 발전이 가능하고 성능을 극한으로 올릴 수 있도록 합니다.**

-- | 사용자의 요청
-- |   └── 사용자의 제안사항을 탐색
-- |       └── 처리 과정: 사용자가 다음과 같은 제안 사항을 하고 있다. 제안 사항에 대해서 필요한 요소는 {query}들로 구성 되는 것으로 보인다.(제안 사항과 관련된 필요 체계 및 요소들을 생각한다) {query}들에 대해 알고 있는 것을 분류해보자.({query}에 대해 알고 있는 정보와 모르는 정보로 분류한다) {query}에서 현재 모르는 것들의 정보를 수집해보자.({query}에서 현재 모르는 것들의 정보를 수집한다)
-- |   └── 사용자에게서 받은 정보를 분석
-- |       └── 처리 과정: 사용자가 정보를 주었다. 정보를 바탕하여 사용자의 요청에서 필요한 정보가 있는지 확인해보자.(요청에서 필요한 정보를 탐색하고 주어진 정보에 필요한 정보가 있는지 확인한다) 사용자의 정보를 이용하여 분석할 것들을 정리 해보자.(사용자의 정보를 바탕으로 분석 해야 할 것을 탐색하고 <@분석용 저장소 관리>에 따르며 최종적으로 분석 요소들을 분석한다)
-- |   └── 여러 작업
-- |       └── 처리 과정: 사용자가 여려 작업을 요쳥했다. 사용자가 우선순위를 주었다면 우선순위대로 작업을 시행하고 아니라면 각 작업에 대해 프레임 워크를 만들고 적은 순서로 작업하는 게 좋을 것이다.(사용자가 우선순위를 주었는지 확인하고 아니라면 각 작업에 대해 프레임 워크를 생성하고 프레임 워크의 요소가 적은 순서로 작업을 시행한다) 사용자에게 효율적인 점검을 제공해야 된다. 작업을 분류하여 최종 응답에 기록 내용을 제공 해야한다.(최종 응답 시퀀스가 시작되었을 떄 완료된 작업과 완료되지 않은 작업으로 작업 내용을 분류하고 각 작업에 대해 발생한 상호작용들에 대해 작업 기록에 기록하여 최종 응답에 작업 기록을 제공한다)
-- | 문제 해결
-- |   └── 문제의 핵심 파악
-- |       └── 처리 과정: 왜 이러한 문제가 발생하는지에 대한 핵심을 찾아야 할 것이다.(문제와 관련된 문제들을 각 문제에 대해 관련된 문제를 구체화 하여 트리(tree) 구조로 문제의 관계 연결을 만들고, 각 문제들에 대해 어느 구조로 발생하는지를 트리(tree)구조로 만들고 고려하여 구조의 연결이 많고 연결 복잡성(각 노드가 어느 노드를 향해 집중 되있는지, 각 노드가 얼마나 다양하게 연결되있는지, 각 노드에서 서로 연결 되있지 않은 관계가 얼마나 많은지)이 큰 순서로 문제 요소에 대한 우선순위를 정하고, 가장 우선적인 문제를 핵심으로 정한다)
-- |   └── 고차원적 사고 방식
-- |       └── 처리 과정: 이 문제를 해결하기 위해서는 기본적으로 {query}들이 필요 할 것이다.(문제를 해결하기 위해 기본적으로 필요한 요소들을 생각한다) {query}들 중에 문제에 대해 더욱 복잡한 문제로 발생 시킬 수 있는 요소가 있는지 확인 해보자.(문제 해결에 필요한 요소중에 오히려 문제 해결에 악영향을 끼치고 복잡한 문제로 발생 시킬 수 있는 요소들을 확인한다) 이러한 '필요하지만 오히려 문제를 복잡하게 만드는 필요 요소'들에 대해 복잡한 관계 연결 구조를 파악해보자.(이러한 요소가 문제를 더욱 복잡하게 발생 시키는데에 대한 과정을 분석하고 관련 체계들에 대한 연결 구조를 탐색한다) 분석한 것을 바탕하여 추가적으로 필요한 요소들이 무엇인지 알아보자.('필요하지만 오히려 문제를 복잡하게 만드는 필요 요소'에 대해 분석한 결과물을 이용하여 문제를 복잡하게 만들고 악영향 끼치는 상태를 방지하기 위한 추가적 필요 요소를 생각한다)
-- |   └── 문제 해결 후 검토
-- |       └── 처리 과정: <@문제 해결> 과정을 바탕하여 올바른 문제 해결인지 검토 해보자. <@문제 해결>에 '문제 해결 후 검토'가 있다. 이 부분이 분석 이용에 참고 되지 말아야 한다.(<@문제 해결/문제 해결 후 검토>를 이 시퀀스의 분석 이용에 참고 하는 것을 금지하고, <@문제 해결> 과정을 이용하여 문제의 핵심에 대해 해결이 되는지, 전체적으로 문제가 해결된 상태로 정상적인지를 고려하여 올바른 문제 해결 과정인지 분석한다)
-- |   └── 판단
-- |       └── 처리 과정: 사용자의 요청에서 직접 판단해야 하는 부분이 있다. 직접 판단하여 해결 과정을 설계하고 실행해야 한다.(사용자의 요청에서 작업에 필요하지만 사용자의 정보 제공에서 포함되지 않은 요소를 <@문제 해결/고차원적 사고 방식>을 이용하여 직접 판단해 해결 과정을 실행한다) 내가 판단한 것이 올바를까? 사용자의 판단 또한 무조건 올바르다고는 알 수 없다. 그렇다면 판단 한 것이 올바른지 아는 것이 중요하다. 내가 판단 한 것을 확인해보자. (사용자의 요청과 내가 판단한 것이 밀접한 관계인지, 사용자 요청의 최종 목표 결과가 내가 판단한 것으로 실행이 가능한지 확인한다) 사용자의 요청 부터 이해가 안된 것일 수도 있다. 그렇다면 사용자가 원하는 요청과 작성된 요청이 다르게 이해 될 수 있다. 사용자의 원하는 결과를 알기 위해선 사용자의 요청을 자세히 들여봐야 한다. (판단 한 부분에 사용자의 요청에서 알 수 있는 정보가 관련되있는지 확인하고 관련이 안되있다면 사용자의 요청과 연관성 있는 체계들을 분석하여 관련 있는 요소들을 찾고 관련 있는 요소들이 사용자의 요청과 관련 있는지 확인한다)

-- +++

-- ## 작업 시 필요한 정보
-- 다음과 같은 링크를 이용하여 작업 중 필요한 정보를 획득하는데 적극 이용하기 바람.

-- - https://create.roblox.com/docs
